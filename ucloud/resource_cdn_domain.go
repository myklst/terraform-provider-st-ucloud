package ucloud

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/cenkalti/backoff/v4"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/myklst/terraform-provider-st-ucloud/ucloud/api"
	"github.com/ucloud/ucloud-sdk-go/services/ucdn"
	uerr "github.com/ucloud/ucloud-sdk-go/ucloud/error"
	"github.com/ucloud/ucloud-sdk-go/ucloud/request"
	"github.com/ucloud/ucloud-sdk-go/ucloud/response"
)

type cacheRuleModel struct {
	PathPattern      types.String `tfsdk:"path_pattern"`
	Description      types.String `tfsdk:"description"`
	TTL              types.Int64  `tfsdk:"ttl"`
	CacheUnit        types.String `tfsdk:"cache_unit"`
	CacheBehavior    types.Bool   `tfsdk:"cache_behavior"`
	FollowOriginRule types.Bool   `tfsdk:"follow_origin_rule"`
	UseRegex         types.Bool   `tfsdk:"use_regex"`
}

type httpCodeCacheModel struct {
	PathPattern      types.String `tfsdk:"path_pattern"`
	Description      types.String `tfsdk:"description"`
	TTL              types.Int64  `tfsdk:"ttl"`
	CacheUnit        types.String `tfsdk:"cache_unit"`
	CacheBehavior    types.Bool   `tfsdk:"cache_behavior"`
	FollowOriginRule types.Bool   `tfsdk:"follow_origin_rule"`
	HttpCode         types.Int64  `tfsdk:"http_code"`
	UseRegex         types.Bool   `tfsdk:"use_regex"`
}

type originConfigModel struct {
	OriginIpList    types.List   `tfsdk:"origin_ip_list"`
	OriginHost      types.String `tfsdk:"origin_host"`
	OriginPort      types.Int64  `tfsdk:"origin_port"`
	OriginProtocol  types.String `tfsdk:"origin_protocol"`
	OriginFollow301 types.Bool   `tfsdk:"origin_follow301"`
}

type cacheConfigModel struct {
	RuleList             []*cacheRuleModel     `tfsdk:"cache_rule"`
	HttpCodeCachRuleList []*httpCodeCacheModel `tfsdk:"http_code_cache_rule"`
}

var referConfigAttributeTypes = map[string]attr.Type{
	"refer_type": types.StringType,
	"null_refer": types.BoolType,
	"refer_list": types.ListType{}.WithElementType(types.StringType),
}

var accessControlConfigAttributeTypes = map[string]attr.Type{
	"ip_blacklist": types.ListType{}.WithElementType(types.StringType),
	"refer_conf":   types.ObjectType{}.WithAttributeTypes(referConfigAttributeTypes),
}

var advancedConfigAttributeTypes = map[string]attr.Type{
	"http_client_header_list": types.ListType{}.WithElementType(types.StringType),
	"http_origin_header_list": types.ListType{}.WithElementType(types.StringType),
	"http_to_https":           types.BoolType,
}

type cdnDomainResourceModel struct {
	DomainId   types.String `tfsdk:"domain_id"`
	Domain     types.String `tfsdk:"domain"`
	Cname      types.String `tfsdk:"cname"`
	Status     types.String `tfsdk:"status"`
	CreateTime types.Int64  `tfsdk:"create_time"`
	TestUrl    types.String `tfsdk:"test_url"`
	AreaCode   types.String `tfsdk:"area_code"`
	CdnType    types.String `tfsdk:"cdn_type"`
	Tag        types.String `tfsdk:"tag"`

	OriginConfig *originConfigModel `tfsdk:"origin_conf"`

	CacheConf *cacheConfigModel `tfsdk:"cache_conf"`

	AccessControlConfig types.Object `tfsdk:"access_control_conf"`

	AdvancedConf types.Object `tfsdk:"advanced_conf"`
}

type cdnDomainResource struct {
	client *ucdn.UCDNClient
}

var (
	_ resource.Resource               = &cdnDomainResource{}
	_ resource.ResourceWithConfigure  = &cdnDomainResource{}
	_ resource.ResourceWithModifyPlan = &cdnDomainResource{}
)

func NewCdnDomainResource() resource.Resource {
	return &cdnDomainResource{}
}

func (r *cdnDomainResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_cdn_domain"
}

func (r *cdnDomainResource) Schema(_ context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "This resource provides the configuration of acceleration domain",
		Attributes: map[string]schema.Attribute{
			"domain_id": &schema.StringAttribute{
				Description: "Id of acceleration domain, generated by ucloud.",
				Computed:    true,
			},
			"domain": &schema.StringAttribute{
				Description: "Acceleration domain",
				Required:    true,
			},
			"cname": &schema.StringAttribute{
				Description: "Cname",
				Computed:    true,
			},
			"status": &schema.StringAttribute{
				Description: "Domain status",
				Computed:    true,
			},
			"create_time": &schema.Int64Attribute{
				Description: "Create time.",
				Computed:    true,
			},
			"test_url": &schema.StringAttribute{
				Description: "Test url",
				Required:    true,
			},
			"area_code": &schema.StringAttribute{
				Description: "Acceleration area.`cn` represents China.`abroad` represents regions outside China.If the value is unset,domain is accelerated in all regions",
				Required:    true,
			},
			"cdn_type": &schema.StringAttribute{
				Description: "`web` for website service,`stream` for video service,`download` for download service",
				Required:    true,
			},
			"tag": &schema.StringAttribute{
				Description: "The group of service.If the value is unset. `Default` is used as default value",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("Default"),
			},
			"advanced_conf": &schema.SingleNestedAttribute{
				Description: "The advance configuration.",
				Attributes: map[string]schema.Attribute{
					"http_client_header_list": schema.ListAttribute{
						Description: "Add http header when send response to client.",
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"http_origin_header_list": schema.ListAttribute{
						Description: "Add http header when send request to origin",
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"http_to_https": schema.BoolAttribute{
						Description: "If perform a forced conversion from http to https.",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
				},
				Computed: true,
				Optional: true,
			},
			"access_control_conf": &schema.SingleNestedAttribute{
				Description: "The configuration of access control.",
				Attributes: map[string]schema.Attribute{
					"ip_blacklist": schema.ListAttribute{
						Description: "Request from address in blacklist will be denied.",
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
						Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
					},
					"refer_conf": &schema.SingleNestedAttribute{
						Description: "",
						Attributes: map[string]schema.Attribute{
							"refer_type": schema.StringAttribute{
								Description: "The type of anti-leech rules.If the value is 0,`refer_list` is whitelist,requests with these refers will be allowed.If the value is 1,`refer_list` is blacklist,requests with these refers will be denied.",
								Optional:    true,
								Computed:    true,
								Default:     stringdefault.StaticString("whitelist"),
								Validators: []validator.String{
									stringvalidator.OneOf("whitelist", "blacklist"),
								},
							},
							"null_refer": schema.BoolAttribute{
								Description: "When `refer_type` is whitelist and `null_refer` is false,NULL refer requests are not allowed.",
								Optional:    true,
								Computed:    true,
								Default:     booldefault.StaticBool(false),
							},
							"refer_list": schema.ListAttribute{
								Description: "The anti-leech rule list",
								ElementType: types.StringType,
								Optional:    true,
								Computed:    true,
								Default:     listdefault.StaticValue(types.ListValueMust(types.StringType, []attr.Value{})),
							},
						},
						Optional: true,
						Computed: true,
					},
				},
				Optional: true,
				Computed: true,
			},
		},
		Blocks: map[string]schema.Block{
			"origin_conf": &schema.SingleNestedBlock{
				Description: "The configuration of origin",
				Attributes: map[string]schema.Attribute{
					"origin_ip_list": schema.ListAttribute{
						Description: "The ip list of origin",
						ElementType: types.StringType,
						Required:    true,
					},
					"origin_host": schema.StringAttribute{
						Description: "The host of origin",
						Optional:    true,
						Computed:    true,
					},
					"origin_port": schema.Int64Attribute{
						Description: "The service port of origin",
						Optional:    true,
						Computed:    true,
						Default:     int64default.StaticInt64(80),
					},
					"origin_protocol": schema.StringAttribute{
						Description: "The protocol of origin.The optional values are `http` and `https`",
						Optional:    true,
						Computed:    true,
						Validators: []validator.String{
							stringvalidator.OneOf("https", "http"),
						},
						Default: stringdefault.StaticString("http"),
					},
					"origin_follow301": schema.BoolAttribute{
						Description: "Whether redirect according to the url from origin.The optional values are true and false",
						Optional:    true,
						Computed:    true,
						Default:     booldefault.StaticBool(false),
					},
				},
			},
			"cache_conf": schema.SingleNestedBlock{
				Description: "The configuration of cache",
				Blocks: map[string]schema.Block{
					"cache_rule": &schema.ListNestedBlock{
						Description: "The list of cache rule",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"path_pattern": schema.StringAttribute{
									Description: "The pattern of path",
									Required:    true,
								},
								"description": schema.StringAttribute{
									Description: "The description of rule",
									Optional:    true,
									Computed:    true,
									Default:     stringdefault.StaticString(""),
								},
								"ttl": schema.Int64Attribute{
									Description: "The cache time",
									Optional:    true,
									Computed:    true,
									Default:     int64default.StaticInt64(0),
								},
								"cache_unit": schema.StringAttribute{
									Description: "The unit of caching time.The optional values are `sec`,`min`,`hour` and `day`.",
									Optional:    true,
									Computed:    true,
									Default:     stringdefault.StaticString("sec"),
								},
								"cache_behavior": schema.BoolAttribute{
									Description: "If caching is enabled.The optional values are true and false.",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
								"follow_origin_rule": schema.BoolAttribute{
									Description: "If follow caching instructions in http header from the origin.The optional values are true and false.",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
								"use_regex": schema.BoolAttribute{
									Description: "If use regex.Default is false",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
							},
						},
					},
					"http_code_cache_rule": &schema.ListNestedBlock{
						Description: "The list of http code cache rule",
						NestedObject: schema.NestedBlockObject{
							Attributes: map[string]schema.Attribute{
								"path_pattern": schema.StringAttribute{
									Description: "The pattern of path",
									Optional:    true,
									Computed:    true,
									Default:     stringdefault.StaticString("/*"),
								},
								"description": schema.StringAttribute{
									Description: "The description of rule",
									Optional:    true,
									Computed:    true,
									Default:     stringdefault.StaticString(""),
								},
								"ttl": schema.Int64Attribute{
									Description: "The cache time",
									Optional:    true,
									Computed:    true,
									Default:     int64default.StaticInt64(0),
								},
								"cache_unit": schema.StringAttribute{
									Description: "The unit of caching time.The optional values are `sec`,`min`,`hour` and `day`.",
									Optional:    true,
									Computed:    true,
									Default:     stringdefault.StaticString("sec"),
								},
								"cache_behavior": schema.BoolAttribute{
									Description: "If caching is enabled.The optional values are true and false.",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
								"follow_origin_rule": schema.BoolAttribute{
									Description: "If follow caching instructions in http header from the origin.The optional values are true and false.",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
								"http_code": schema.Int64Attribute{
									Description: "Http code,range from 200 to 600,200 and 206 are not allowed.",
									Required:    true,
									Validators: []validator.Int64{
										int64validator.Between(200, 600),
										int64validator.NoneOf(200, 206),
									},
								},
								"use_regex": schema.BoolAttribute{
									Description: "If use regex.Default is false",
									Optional:    true,
									Computed:    true,
									Default:     booldefault.StaticBool(false),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (r *cdnDomainResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(ucloudClients).cdnClient
}

func (r *cdnDomainResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var (
		model                   *cdnDomainResourceModel
		createCdnDomainResponse api.CreateCdnDomainResponse
	)

	resp.Diagnostics.Append(req.Plan.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}
	createCdnDomainRequest, diags := r.buildCreateCdnDomainRequest(model)
	if diags.HasError() {
		resp.Diagnostics.Append(diags...)
		return
	}

	var err error
	createCdnDomain := func() error {
		err = r.client.InvokeAction("BatchCreateNewUcdnDomain", createCdnDomainRequest, &createCdnDomainResponse)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			if api.Retryable(createCdnDomainResponse.RetCode) {
				return errors.New(createCdnDomainResponse.Message)
			}
			return backoff.Permanent(err)
		}

		if len(createCdnDomainResponse.DomainList) == 0 {
			return backoff.Permanent(fmt.Errorf("%s", "domain list is empty"))
		}
		if createCdnDomainResponse.DomainList[0].RetCode != 0 {
			return backoff.Permanent(fmt.Errorf("%s", createCdnDomainResponse.DomainList[0].Message))
		}

		return nil
	}
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(createCdnDomain, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Create CdnDomain", err.Error())
		return
	}
	model.DomainId = types.StringValue(createCdnDomainResponse.DomainList[0].DomainId)
	_, err = api.WaitForDomainStatus(r.client, model.DomainId.ValueString(), []string{api.DomainStatusEnable, api.DomainStatusChekFail})
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Get CdnDomain Status", err.Error())
		return
	}

	err = api.UpdateCdnDomain(r.client, r.buildUpdateCdnDomainRequest(model))
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Update CdnDomain", err.Error())
	}

	domainConfig, err := api.GetUcdnDomainConfig(r.client, model.DomainId.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Get CdnDomain", err.Error())
		return
	}

	resp.Diagnostics.Append(updateUcloudCdnDomainResourceModel(ctx, model, domainConfig)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.State.Set(ctx, model)
}

func (r *cdnDomainResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var model *cdnDomainResourceModel
	resp.Diagnostics.Append(req.State.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	domainConfig, err := api.GetUcdnDomainConfig(r.client, model.DomainId.ValueString())
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Read CdnDomain", err.Error())
		return
	}

	if domainConfig == nil {
		resp.State.RemoveResource(ctx)
		return
	}

	resp.Diagnostics.Append(updateUcloudCdnDomainResourceModel(ctx, model, domainConfig)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(resp.State.Set(ctx, &model)...)
}

func (r *cdnDomainResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var (
		model *cdnDomainResourceModel
		state *cdnDomainResourceModel
	)

	resp.Diagnostics.Append(req.Plan.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	model.DomainId = state.DomainId

	err := api.UpdateCdnDomain(r.client, r.buildUpdateCdnDomainRequest(model))
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Update CdnDomain", err.Error())
	}

	copyUcloudCdnDomainResourceModelComputeFields(model, state)
	model.Status = types.StringValue(api.DomainStatusEnable)

	resp.State.Set(ctx, &model)
}

func (r *cdnDomainResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var (
		model                          *cdnDomainResourceModel
		updateUcdnDomainStatusResponse response.CommonBase
	)
	resp.Diagnostics.Append(req.State.Get(ctx, &model)...)
	if resp.Diagnostics.HasError() {
		return
	}

	updateUcdnDomainStatusRequest := &struct {
		request.CommonBase
		DomainId string
		Status   string
		IsDcdn   bool
	}{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainId: model.DomainId.ValueString(),
		Status:   "delete",
		IsDcdn:   false,
	}

	var err error
	updateDomainStatus := func() error {
		err = r.client.InvokeAction("UpdateUcdnDomainStatus", updateUcdnDomainStatusRequest, &updateUcdnDomainStatusResponse)
		if err != nil {
			if cErr, ok := err.(uerr.ClientError); ok && cErr.Retryable() {
				return err
			}
			if api.Retryable(updateUcdnDomainStatusResponse.RetCode) {
				return errors.New(updateUcdnDomainStatusResponse.Message)
			}
			return backoff.Permanent(err)
		}
		return nil
	}
	reconnectBackoff := backoff.NewExponentialBackOff()
	reconnectBackoff.MaxElapsedTime = 30 * time.Second
	err = backoff.Retry(updateDomainStatus, reconnectBackoff)
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to Update CdnDomain", err.Error())
		return
	}
	_, err = api.WaitForDomainStatus(r.client, model.DomainId.ValueString(), []string{api.DomainStatusDelete})
	if err != nil {
		resp.Diagnostics.AddError("[API ERROR] Fail to get update status", err.Error())
		return
	}
}

func (r *cdnDomainResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("domain_id"), req, resp)
}

func (r *cdnDomainResource) ModifyPlan(ctx context.Context, req resource.ModifyPlanRequest, resp *resource.ModifyPlanResponse) {
	var plan *cdnDomainResourceModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	if plan == nil {
		return
	}

	if plan.OriginConfig != nil {
		if plan.OriginConfig.OriginHost.IsNull() || plan.OriginConfig.OriginHost.IsUnknown() {
			plan.OriginConfig.OriginHost = plan.Domain
		}
	}

	if plan.CacheConf == nil {
		plan.CacheConf = &cacheConfigModel{}
	}
	if plan.CacheConf.RuleList == nil || len(plan.CacheConf.RuleList) == 0 {
		rule := &cacheRuleModel{
			PathPattern:      types.StringValue("/"),
			TTL:              types.Int64Value(0),
			CacheUnit:        types.StringValue("sec"),
			Description:      types.StringValue(""),
			CacheBehavior:    types.BoolValue(true),
			FollowOriginRule: types.BoolValue(false),
			UseRegex:         types.BoolValue(false),
		}
		plan.CacheConf.RuleList = []*cacheRuleModel{rule}
	}
	resp.Plan.SetAttribute(ctx, path.Root("cache_conf"), plan.CacheConf)

	if plan.AdvancedConf.IsNull() || plan.AdvancedConf.IsUnknown() {
		plan.AdvancedConf = types.ObjectValueMust(advancedConfigAttributeTypes, map[string]attr.Value{
			"http_client_header_list": types.ListValueMust(types.StringType, []attr.Value{}),
			"http_origin_header_list": types.ListValueMust(types.StringType, []attr.Value{}),
			"http_to_https":           types.BoolValue(false),
		})
	}

	if plan.AccessControlConfig.IsNull() || plan.AccessControlConfig.IsUnknown() || plan.AccessControlConfig.Attributes()["refer_conf"].IsNull() || plan.AccessControlConfig.Attributes()["refer_conf"].IsUnknown() {
		referConfig := types.ObjectValueMust(referConfigAttributeTypes, map[string]attr.Value{
			"refer_list": types.ListValueMust(types.StringType, []attr.Value{}),
			"null_refer": types.BoolValue(false),
			"refer_type": types.StringValue("whitelist"),
		})
		if plan.AccessControlConfig.IsNull() || plan.AccessControlConfig.IsUnknown() {
			plan.AccessControlConfig = types.ObjectValueMust(accessControlConfigAttributeTypes, map[string]attr.Value{
				"ip_blacklist": types.ListValueMust(types.StringType, []attr.Value{}),
				"refer_conf":   referConfig,
			})
		} else {
			plan.AccessControlConfig = types.ObjectValueMust(accessControlConfigAttributeTypes, map[string]attr.Value{
				"ip_blacklist": plan.AccessControlConfig.Attributes()["ip_blacklist"],
				"refer_conf":   referConfig,
			})
		}
	}

	resp.Diagnostics.Append(resp.Plan.Set(ctx, &plan)...)
}

func (r *cdnDomainResource) buildCreateCdnDomainRequest(m *cdnDomainResourceModel) (*api.CreateCdnDomainRequest, diag.Diagnostics) {
	var diags diag.Diagnostics
	domainConfig := api.CreateDomainConfig{}
	domainConfig.Domain = m.Domain.ValueString()
	diags.Append(m.OriginConfig.OriginIpList.ElementsAs(nil, &domainConfig.OriginIp, false)...)
	if m.OriginConfig != nil {
		domainConfig.OriginHost = m.OriginConfig.OriginHost.ValueString()
	}
	domainConfig.TestUrl = m.TestUrl.ValueString()
	if m.CacheConf != nil {
		domainConfig.CacheConf = make([]api.CreateDomainCacheConf, 0)
		for _, rule := range m.CacheConf.RuleList {
			cc := api.CreateDomainCacheConf{}
			cc.PathPattern = rule.PathPattern.ValueString()
			cc.CacheTTL = rule.TTL.ValueInt64()
			cc.CacheUnit = rule.CacheUnit.ValueString()
			cc.CacheBehavior = rule.CacheBehavior.ValueBool()
			domainConfig.CacheConf = append(domainConfig.CacheConf, cc)
		}
	}
	domainConfig.AreaCode = m.AreaCode.ValueStringPointer()
	domainConfig.CdnType = m.CdnType.ValueStringPointer()
	domainConfig.Tag = m.TestUrl.ValueStringPointer()

	return &api.CreateCdnDomainRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainList: []api.CreateDomainConfig{domainConfig},
	}, diags
}

func (r *cdnDomainResource) buildUpdateCdnDomainRequest(m *cdnDomainResourceModel) *api.UpdateCdnDomainRequest {
	domainConf := api.UpdateCdnDomainConfig{}
	domainConf.DomainId = m.DomainId.ValueString()
	// origin
	if m.OriginConfig != nil {
		m.OriginConfig.OriginIpList.ElementsAs(nil, &domainConf.OriginConf.OriginIp, false)
		domainConf.OriginConf.OriginHost = m.OriginConfig.OriginHost.ValueStringPointer()
		domainConf.OriginConf.OriginPort = m.OriginConfig.OriginPort.ValueInt64Pointer()
		domainConf.OriginConf.OriginProtocol = m.OriginConfig.OriginProtocol.ValueStringPointer()
		val := int64(0)
		if m.OriginConfig.OriginFollow301.ValueBool() {
			val = 1
		}
		domainConf.OriginConf.OriginFollow301 = &val
	}
	// cache control
	if m.CacheConf != nil {
		domainConf.CacheConf.CacheList = make([]api.CdnCacheRule, 0)
		for _, rule := range m.CacheConf.RuleList {
			rule := api.CdnCacheRule{
				PathPattern:      rule.PathPattern.ValueString(),
				CacheTTL:         int(rule.TTL.ValueInt64()),
				CacheUnit:        rule.CacheUnit.ValueString(),
				CacheBehavior:    rule.CacheBehavior.ValueBool(),
				Description:      rule.Description.ValueString(),
				FollowOriginRule: rule.FollowOriginRule.ValueBool(),
			}
			domainConf.CacheConf.CacheList = append(domainConf.CacheConf.CacheList, rule)
		}
		domainConf.CacheConf.HttpCodeCacheList = make([]api.CdnCacheRule, 0)
		for _, rule := range m.CacheConf.HttpCodeCachRuleList {
			rule := api.CdnCacheRule{
				PathPattern:      rule.PathPattern.ValueString(),
				CacheTTL:         int(rule.TTL.ValueInt64()),
				CacheUnit:        rule.CacheUnit.ValueString(),
				CacheBehavior:    rule.CacheBehavior.ValueBool(),
				Description:      rule.Description.ValueString(),
				FollowOriginRule: rule.FollowOriginRule.ValueBool(),
				HttpCodePattern:  fmt.Sprintf("%d", rule.HttpCode.ValueInt64()),
			}
			domainConf.CacheConf.HttpCodeCacheList = append(domainConf.CacheConf.HttpCodeCacheList, rule)
		}
	}
	// access control
	if !m.AccessControlConfig.IsNull() {
		m.AccessControlConfig.Attributes()["ip_blacklist"].(types.List).ElementsAs(nil, &domainConf.AccessControlConf.IpBlackList, false)
		if len(domainConf.AccessControlConf.IpBlackList) == 0 {
			domainConf.AccessControlConf.IpBlackListEmpty = true
		}
		nullRefer := m.AccessControlConfig.Attributes()["refer_conf"].(types.Object).Attributes()["null_refer"].(types.Bool).ValueBoolPointer()
		if nullRefer == nil {
			domainConf.AccessControlConf.ReferConf.NullRefer = nil
		} else {
			val := 0
			if *nullRefer {
				val = 1
			}
			domainConf.AccessControlConf.ReferConf.NullRefer = &val
		}
		referType := m.AccessControlConfig.Attributes()["refer_conf"].(types.Object).Attributes()["refer_type"].(types.String).ValueStringPointer()
		if referType == nil {
			domainConf.AccessControlConf.ReferConf.ReferType = nil
		} else {
			val := 0
			if *referType == "blacklist" {
				val = 1
			}
			domainConf.AccessControlConf.ReferConf.ReferType = &val
		}
		m.AccessControlConfig.Attributes()["refer_conf"].(types.Object).Attributes()["refer_list"].(types.List).ElementsAs(nil, &domainConf.AccessControlConf.ReferConf.ReferList, false)
		if len(domainConf.AccessControlConf.ReferConf.ReferList) == 0 {
			domainConf.AccessControlConf.EnableRefer = false
		} else {
			domainConf.AccessControlConf.EnableRefer = true
		}
	}
	// advanced config
	if !m.AdvancedConf.IsNull() {
		domainConf.AdvancedConf.Http2Https = m.AdvancedConf.Attributes()["http_to_https"].(types.Bool).ValueBoolPointer()
		m.AdvancedConf.Attributes()["http_client_header_list"].(types.List).ElementsAs(nil, &domainConf.AdvancedConf.HttpClientHeader, false)
		if len(domainConf.AdvancedConf.HttpClientHeader) == 0 {
			domainConf.AdvancedConf.HttpClientHeaderEmpty = true
		} else {
			domainConf.AdvancedConf.HttpClientHeaderEmpty = false
		}
		m.AdvancedConf.Attributes()["http_origin_header_list"].(types.List).ElementsAs(nil, &domainConf.AdvancedConf.HttpOriginHeader, false)
		if len(domainConf.AdvancedConf.HttpOriginHeader) == 0 {
			domainConf.AdvancedConf.HttpOriginHeaderEmpty = true
		} else {
			domainConf.AdvancedConf.HttpOriginHeaderEmpty = false
		}
	}

	return &api.UpdateCdnDomainRequest{
		CommonBase: request.CommonBase{
			ProjectId: &r.client.GetConfig().ProjectId,
		},
		DomainList: []api.UpdateCdnDomainConfig{domainConf},
	}
}

func updateUcloudCdnDomainResourceModelComputeFields(model *cdnDomainResourceModel, info *ucdn.DomainConfigInfo) {
	model.DomainId = types.StringValue(info.DomainId)
	model.Cname = types.StringValue(info.Cname)
	model.Status = types.StringValue(info.Status)
	model.CreateTime = types.Int64Value(int64(info.CreateTime))
	if model.OriginConfig != nil {
		model.OriginConfig.OriginHost = types.StringValue(info.OriginConf.OriginHost)
	}
}

func copyUcloudCdnDomainResourceModelComputeFields(dst, src *cdnDomainResourceModel) {
	dst.DomainId = src.DomainId
	dst.Cname = src.Cname
	dst.Status = src.Status
	dst.CreateTime = src.CreateTime
}

func updateUcloudCdnDomainResourceModel(ctx context.Context, model *cdnDomainResourceModel, info *api.DomainConfigInfo) diag.Diagnostics {
	var diags, result diag.Diagnostics

	if info == nil {
		result.AddError("[Invalid response]", "domain config is nil")
		return result
	}

	model.AreaCode = types.StringValue(info.AreaCode)
	model.CdnType = types.StringValue(info.CdnType)
	model.Status = types.StringValue(info.Status)
	model.Cname = types.StringValue(info.Cname)
	model.CreateTime = types.Int64Value(int64(info.CreateTime))
	model.TestUrl = types.StringValue(info.TestUrl)

	model.OriginConfig = &originConfigModel{}
	model.OriginConfig.OriginIpList, diags = types.ListValueFrom(ctx, types.StringType, info.OriginConf.OriginIpList)
	result.Append(diags...)
	if model.OriginConfig.OriginIpList.IsNull() {
		model.OriginConfig.OriginIpList = types.ListValueMust(types.StringType, []attr.Value{})
	}
	model.OriginConfig.OriginHost = types.StringValue(info.OriginConf.OriginHost)
	model.OriginConfig.OriginPort = types.Int64Value(int64(info.OriginConf.OriginPort))
	model.OriginConfig.OriginProtocol = types.StringValue(info.OriginConf.OriginProtocol)
	if info.OriginConf.OriginFollow301 == 1 {
		model.OriginConfig.OriginFollow301 = types.BoolValue(true)
	} else {
		model.OriginConfig.OriginFollow301 = types.BoolValue(false)
	}

	model.CacheConf = &cacheConfigModel{}
	model.CacheConf.RuleList = make([]*cacheRuleModel, 0)
	model.CacheConf.HttpCodeCachRuleList = make([]*httpCodeCacheModel, 0)
	for _, rule := range info.CacheConf.CacheList {
		c := &cacheRuleModel{
			PathPattern:      types.StringValue(rule.PathPattern),
			Description:      types.StringValue(rule.Description),
			TTL:              types.Int64Value(int64(rule.CacheTTL)),
			CacheUnit:        types.StringValue(rule.CacheUnit),
			CacheBehavior:    types.BoolValue(rule.CacheBehavior),
			FollowOriginRule: types.BoolValue(rule.FollowOriginRule),
			UseRegex:         types.BoolValue(rule.UseRegex),
		}
		model.CacheConf.RuleList = append(model.CacheConf.RuleList, c)
	}
	for _, rule := range info.CacheConf.HttpCodeCacheList {
		c := &httpCodeCacheModel{
			PathPattern:      types.StringValue(rule.PathPattern),
			Description:      types.StringValue(rule.Description),
			TTL:              types.Int64Value(int64(rule.CacheTTL)),
			CacheUnit:        types.StringValue(rule.CacheUnit),
			CacheBehavior:    types.BoolValue(rule.CacheBehavior),
			FollowOriginRule: types.BoolValue(rule.FollowOriginRule),
			UseRegex:         types.BoolValue(rule.UseRegex),
		}
		code, err := strconv.Atoi(rule.HttpCodePattern)
		if err != nil {
			result.AddError("[Invalid Api Response]", err.Error())
			return result
		}
		c.HttpCode = types.Int64Value(int64(code))
		model.CacheConf.HttpCodeCachRuleList = append(model.CacheConf.HttpCodeCachRuleList, c)
	}

	referList, diags := types.ListValueFrom(ctx, types.StringType, info.AccessControlConf.ReferConf.ReferList)
	result.Append(diags...)
	if referList.IsNull() {
		referList = types.ListValueMust(types.StringType, []attr.Value{})
	}
	referType := "whitelist"
	if info.AccessControlConf.ReferConf.ReferType == 1 {
		referType = "blacklist"
	}
	nullRefer := false
	if info.AccessControlConf.ReferConf.NullRefer == 1 {
		nullRefer = true
	}
	referConfig := types.ObjectValueMust(referConfigAttributeTypes, map[string]attr.Value{
		"refer_type": types.StringValue(referType),
		"null_refer": types.BoolValue(nullRefer),
		"refer_list": referList,
	})
	ipBlackList, diags := types.ListValueFrom(ctx, types.StringType, info.AccessControlConf.IpBlackList)
	result.Append(diags...)
	if ipBlackList.IsNull() {
		ipBlackList = types.ListValueMust(types.StringType, []attr.Value{})
	}
	model.AccessControlConfig = types.ObjectValueMust(accessControlConfigAttributeTypes, map[string]attr.Value{
		"refer_conf":   referConfig,
		"ip_blacklist": ipBlackList,
	})

	clientHeaderList, diags := types.ListValueFrom(ctx, types.StringType, info.AdvancedConf.HttpClientHeader)
	result.Append(diags...)
	if clientHeaderList.IsNull() {
		clientHeaderList = types.ListValueMust(types.StringType, []attr.Value{})
	}
	originHeaderList, diags := types.ListValueFrom(ctx, types.StringType, info.AdvancedConf.HttpOriginHeader)
	result.Append(diags...)
	if originHeaderList.IsNull() {
		originHeaderList = types.ListValueMust(types.StringType, []attr.Value{})
	}
	model.AdvancedConf = types.ObjectValueMust(advancedConfigAttributeTypes, map[string]attr.Value{
		"http_client_header_list": clientHeaderList,
		"http_origin_header_list": originHeaderList,
		"http_to_https":           types.BoolValue(info.AdvancedConf.Http2Https),
	})

	return result
}
